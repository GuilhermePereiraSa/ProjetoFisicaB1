# üé± Simula√ß√£o de Colis√µes com Part√≠culas e Bola de Sinuca
## üìñ Introdu√ß√£o
Este projeto √© uma simula√ß√£o interativa que combina conceitos de f√≠sica computacional com a programa√ß√£o de um pequeno jogo. Ele simula as colis√µes entre part√≠culas (como bolas de sinuca), criando uma interface visual para demonstrar fen√¥menos f√≠sicos como conserva√ß√£o de momento e colis√µes el√°sticas.

### Objetivos
- Simular colis√µes entre part√≠culas e objetos em um ambiente controlado.
- Demonstrar conceitos de f√≠sica como conserva√ß√£o de energia e momentum.
- Criar uma interface visual interativa utilizando a biblioteca Pygame.
O projeto √© inspirado no cap√≠tulo 2 do livro Computational Physics e em v√≠deos educativos como Building Collision Simulations do canal Reducible. A ideia surgiu do desejo de criar uma aplica√ß√£o que una teoria f√≠sica e programa√ß√£o em uma experi√™ncia pr√°tica.

### Como usar
Instalar as depend√™ncias necess√°rias:
```bash
pip install pygame
```
```bash
pip install numpy
```
Ou use o alternativo, se necess√°rio:

```bash
sudo apt install python3-pygame
```

```bash
sudo apt install python3-numpy
```

### Simula√ß√£o e Intera√ß√£o
A simula√ß√£o √© controlada por uma interface gr√°fica, onde o usu√°rio pode ver e interagir com as part√≠culas (bolas de sinuca). O comportamento das colis√µes, as energias cin√©ticas e potenciais, al√©m do movimento das bolas, s√£o visualizados em tempo real.

## üõ† Desenvolvimento
### üì¶ Estrutura do Projeto
O projeto est√° dividido em duas partes principais: o 2d-colision e o pool-game.py.
Falamos aqui somente do 2d-colision porque √© o mais completo do projeto. Fica como observa√ß√£o o 2¬∫ projeto, pois ele √© mais direto.

### Simula√ß√£o de F√≠sica:

#### Part√≠culas: Implementa√ß√£o de part√≠culas com propriedades como posi√ß√£o, velocidade, massa e raio.
Gerenciamento de colis√µes: Utiliza√ß√£o de vetores e leis de conserva√ß√£o para detectar e processar colis√µes.
Atualiza√ß√£o do estado das part√≠culas: Movimenta√ß√£o das part√≠culas ao longo do tempo, com simula√ß√£o de for√ßa gravitacional e colis√µes el√°sticas.
Interface de Sinuca:

#### Mesa de Sinuca: Representa√ß√£o gr√°fica de uma mesa de sinuca usando Pygame.
- Bolas de Sinuca: Cria√ß√£o de bolas (part√≠culas) que se movem na mesa e colidem entre si.
- Gerenciamento de colis√µes com bols√µes e bordas: Detec√ß√£o de colis√µes das bolas com os limites da mesa e os bols√µes.
#### Fluxo do C√≥digo
O c√≥digo simula as part√≠culas em um ambiente 2D (mesa de sinuca) onde as bolas colidem entre si e com as bordas. A f√≠sica das colis√µes √© baseada em conceitos reais de conserva√ß√£o de energia e momentum, com a intera√ß√£o visual sendo feita com Pygame.

#### Part√≠culas s√£o criadas com atributos como massa, posi√ß√£o, velocidade e raio.
- Colis√µes s√£o detectadas e resolvidas usando a f√≠sica de colis√µes el√°sticas (conserva√ß√£o de energia cin√©tica e momentum).
- Movimento das part√≠culas √© calculado a cada quadro com a aplica√ß√£o de acelera√ß√£o devido √† gravidade e intera√ß√µes de colis√£o.

```python
import pygame
import numpy as np
```

##### Parte principal do c√≥digo que trata conceitos f√≠sicos

```python

    def kinetic_energy(self):
        # KE = 0.5 * m * v^2
        velocity_magnitude = np.linalg.norm(self.vel)
        return 0.5 * self.mass * velocity_magnitude**2

    def potential_energy(self, ground_level=0):
        # PE = m * g * h (h √© a altura acima do ch√£o)
        height = max(0, self.pos[1] - self.radius - ground_level)
        return self.mass * GRAVITY * height

    def mechanical_energy(self, ground_level=0):
        # ME = KE + PE
        return self.kinetic_energy() + self.potential_energy(ground_level)

```

#### Parte explicativa dos conceitos f√≠sicos:

##### A energia cin√©tica √© calculada sempre desta forma, pois independe do sistema, de suas for√ßas aplicadas, se s√£o conservativas, etc., isto porque √© algo "pertencente" do objeto, depende de sua velocidade, $$\vec{v}$$, e de sua carga inercial, $$m$$

```markdown
    
A energia cin√©tica de um corpo pode ser provada utilizando a rela√ß√£o entre for√ßa, deslocamento e trabalho.

Come√ßamos com a defini√ß√£o de trabalho realizado por uma for√ßa:
\[
W = \int \vec{F} \cdot d\vec{s}
\]

Usando a segunda lei de Newton, temos que a for√ßa √© dada por:
\[
\vec{F} = m \vec{a}
\]
onde \( m \) √© a massa do corpo e \( \vec{a} \) √© a acelera√ß√£o.

Substitu√≠mos \( \vec{F} \) na equa√ß√£o do trabalho:
\[
W = \int m \vec{a} \cdot d\vec{s}
\]

Sabemos que \( \vec{a} = \frac{d\vec{v}}{dt} \), e podemos reescrever \( d\vec{s} \) em termos de \( \vec{v} \) e \( dt \):
\[
d\vec{s} = \vec{v} dt
\]

Substituindo na equa√ß√£o:
\[
W = \int m \frac{d\vec{v}}{dt} \cdot \vec{v} dt
\]

Cancelando \( dt \) e reescrevendo a equa√ß√£o:
\[
W = \int m \vec{v} \cdot d\vec{v}
\]

Expandindo o produto escalar \( \vec{v} \cdot d\vec{v} \), temos:
\[
W = m \int v \, dv
\]

Integrando:
\[
W = \frac{1}{2} m v^2 + C
\]

Assumindo \( C = 0 \) para o caso inicial, o trabalho realizado √© igual √† energia cin√©tica:
\[
W = \frac{1}{2} m v^2
\]

Assim, mostramos que a energia cin√©tica √© dada por:
\[
E_k = \frac{1}{2} m v^2
\]
```
##### A energia pot√™ncial depende da posi√ß√£o em rela√ß√£o √† algo, geralmente ao "ch√£o", aqui √© do mesmo modo, com o limite "bottom", percebe-se que a energia pot√™ncial do objeto part√≠cula ao tocar no ch√£o √© 0. 

```markdown 
**Defini√ß√£o de For√ßa Conservativa**  
A energia potencial em um campo de for√ßas conservativas √© definida como:
\[
E_p(r) = - \int \vec{F} \cdot d\vec{r},
\]
onde \(\vec{F}\) √© a for√ßa que age no sistema e \(d\vec{r}\) √© o deslocamento infinitesimal.

**For√ßa Gravitacional**  
No caso da queda livre, a for√ßa que atua √© o peso do corpo, dado por:
\[
\vec{F} = m\vec{g},
\]
onde \(m\) √© a massa do corpo e \(\vec{g}\) √© o vetor acelera√ß√£o da gravidade.

**Escolha do Referencial**  
Escolhemos um referencial em que o deslocamento ocorre ao longo do eixo vertical (\(z\)), positivo para cima. Assim:
\[
d\vec{r} = dz \hat{k}.
\]
A for√ßa gravitacional aponta para baixo (\(-\hat{k}\)), e o produto escalar \(\vec{F} \cdot d\vec{r}\) √©:
\[
\vec{F} \cdot d\vec{r} = -mg \, dz.
\]

**C√°lculo da Energia Potencial**  
Substitu√≠mos a express√£o da for√ßa no c√°lculo da energia potencial:
\[
E_p(z) = - \int \vec{F} \cdot d\vec{r} = - \int (-mg) \, dz.
\]

**Integra√ß√£o**  
A integral resulta em:
\[
E_p(z) = \int mg \, dz = mgz + C,
\]
onde \(C\) √© a constante de integra√ß√£o.

**Defini√ß√£o do Referencial**  
Escolhemos o referencial em que a energia potencial √© zero (\(E_p = 0\)) no n√≠vel \(z = 0\). Assim, \(C = 0\) e a energia potencial √©:
\[
E_p(z) = mgz.
\]

**Substitui√ß√£o do Altura (\(h\))**  
Chamando a coordenada vertical \(z\) de altura \(h\), obtemos:
\[
E_p(h) = mgh.
\]

```


##### Agora a energia mec√¢nica √© a soma da energia pot√™ncial e cin√©tica, e dependendo do sistema, i.e, se for constituido apenas de for√ßas conservativas, a $$E_m$$ ser√° 0.

```markdown
$$E_m = E_p + E_c $$
```

```python
def calculate_center_of_mass(particles):
    total_mass = sum(p.mass for p in particles)
    if total_mass == 0:
        return np.array([0, 0])
    weighted_positions = sum(p.mass * p.pos for p in particles)
    return weighted_positions / total_mass
```

##### O conceito de centro de massa foi introduzido em C√°lculo II, onde as principais vari√°veis s√£o: œÅ(x) com a somat√≥ria das massas, em que cada massa i √© multiplicada por sua posi√ß√£o, sua largura na fun√ß√£o, na posi√ß√£o i, sendo tudo isso dividido pela somat√≥ria total das massas. S√≥ que aqui em f√≠sica b√°sica 1 a gente s√≥ faz uma m√©dia ponderada.

\[
x_{\text{cm}} = \frac{\sum_{i=1}^{n} m_i \cdot x_i}{\sum_{i=1}^{n} m_i}
\]


#### Conceitos b√°sicos do c√≥digo

Quando criamos um simulador de part√≠culas, precisamos representar cada part√≠cula e implementar m√©todos para calcular suas intera√ß√µes f√≠sicas. 

### Representa√ß√£o das Part√≠culas e Sistema de Coordenadas

Cada part√≠cula √© representada por uma posi√ß√£o em 2D, onde:

- `pos[0]`: Coordenada \(x\).
- `pos[1]`: Coordenada \(y\).

A imagem abaixo ilustra tr√™s poss√≠veis casos de detec√ß√£o de colis√£o:

![3 Casos da Detec√ß√£o](img/3casosDeteccao.png)

## Conceito Final

### Conserva√ß√£o do Momento Linear

A **conserva√ß√£o do momento linear** √© um princ√≠pio impl√≠cito no c√≥digo. Durante uma colis√£o, o momento total do sistema (soma do produto da massa pela velocidade de todas as part√≠culas) permanece constante. No c√≥digo, isso √© implementado ajustando as velocidades das part√≠culas proporcionalmente √†s suas massas, aplicando o impulso gerado pela colis√£o.

### Coeficiente de Restitui√ß√£o

O **coeficiente de restitui√ß√£o** (`restitution`) define a elasticidade da colis√£o, influenciando a fra√ß√£o da velocidade relativa mantida ap√≥s a colis√£o:

- `restitution = 1`: Colis√£o perfeitamente el√°stica (sem perda de energia cin√©tica).
- \(0 < \text{restitution} < 1\): Colis√£o parcialmente el√°stica (h√° dissipa√ß√£o de energia).
- `restitution = 0`: Colis√£o perfeitamente inel√°stica (as part√≠culas "grudam").

No sistema, utilizamos `restitution = 0.9`, indicando uma colis√£o predominantemente el√°stica, mas com alguma dissipa√ß√£o de energia.

### Conceito de Impulso

O **impulso** √© a grandeza f√≠sica respons√°vel por alterar o momento linear de um corpo durante uma colis√£o. Ele √© definido como:

\[
\mathbf{J} = \Delta \mathbf{P}
\]

onde \(\Delta \mathbf{P}\) √© a varia√ß√£o do momento linear. Em termos pr√°ticos, o impulso √© o produto da for√ßa m√©dia aplicada a um corpo pelo intervalo de tempo durante o qual ela atua:

\[
\mathbf{J} = \mathbf{F} \cdot \Delta t
\]

No c√≥digo, o impulso escalar √© calculado como:

\[
J = \frac{-(1 + \text{restitution}) \cdot v_{\text{rel,along normal}}}{\frac{1}{m_1} + \frac{1}{m_2}}
\]

Onde:

- `restitution`: Coeficiente de restitui√ß√£o.
- \(v_{\text{rel,along normal}}\): Velocidade relativa das part√≠culas ao longo do vetor normal de colis√£o.
- \(m_1\) e \(m_2\): Massas das part√≠culas.

O vetor impulso √© dado por:

\[
\mathbf{J} = J \cdot \mathbf{n}
\]

onde \(\mathbf{n}\) √© o vetor normal √† superf√≠cie de colis√£o.

O impulso √© aplicado proporcionalmente √†s massas das part√≠culas para ajustar suas velocidades, garantindo a conserva√ß√£o do momento linear e respeitando o coeficiente de restitui√ß√£o:

\[
\mathbf{v}_{1,\text{depois}} = \mathbf{v}_{1,\text{antes}} + \frac{\mathbf{J}}{m_1}
\]

\[
\mathbf{v}_{2,\text{depois}} = \mathbf{v}_{2,\text{antes}} - \frac{\mathbf{J}}{m_2}
\]

## Refer√™ncias

- **Livro**: *Computational Physics* (Cap√≠tulo 2)
- **Canal**: *Reducible* ‚Äì [Building Collision Simulations](https://www.youtube.com/watch?v=eED4bSkYCB8&ab_channel=Reducible)
- BERNARDES, Esmerindo. Materiais Did√°ticos: **Notas de Aula**. Dispon√≠vel em: <edisciplinas.usp.br>. Acesso em: 6 dez. 2024.
